import { useEffect, useRef, useState } from "react";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Card } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { FileText, Eye, Sparkles, Loader2, Table2, BarChart3, Trash2, Lightbulb } from "lucide-react";
import { toast } from "sonner";
import { humanizeText, GigaChatError, TableData, ChartData, TableType, generateTable, generateChartData, analyzeSectionForVisuals } from "@/lib/gigachat";

interface Section {
  id: string;
  title: string;
  description: string;
  content?: string;
  tables?: TableData[];
  charts?: ChartData[];
}

interface DocumentEditorProps {
  sections: Section[];
  theme: string;
  onNext: (sections: Section[]) => void;
  onBack: () => void;
}

export const DocumentEditor = ({ sections: initialSections, theme, onNext, onBack }: DocumentEditorProps) => {
  const [sections, setSections] = useState<Section[]>(initialSections.map(s => ({
    ...s,
    tables: s.tables || [],
    charts: s.charts || []
  })));
  const [activeTab, setActiveTab] = useState("edit");
  const [humanizingId, setHumanizingId] = useState<string | null>(null);
  const [generatingTable, setGeneratingTable] = useState<{ sectionId: string; type: TableType } | null>(null);
  const [generatingChart, setGeneratingChart] = useState<{ sectionId: string; type: 'line' | 'bar' | 'pie' } | null>(null);
  const autoGeneratedTables = useRef<Set<string>>(new Set());
  const autoGeneratedCharts = useRef<Set<string>>(new Set());
  const autoHumanizedSections = useRef<Set<string>>(new Set());
  const rateLimitReachedRef = useRef(false);
  const rateLimitToastShownRef = useRef(false);

  const notifyRateLimit = (toastId?: string) => {
    rateLimitReachedRef.current = true;

    if (toastId) {
      toast.error("GigaChat временно ограничил запросы", {
        id: toastId,
        description: "Подождите 1–2 минуты и повторите попытку. Вы можете продолжить редактирование вручную.",
      });
      rateLimitToastShownRef.current = true;
      return;
    }

    if (!rateLimitToastShownRef.current) {
      toast.error("GigaChat временно ограничил запросы", {
        description: "Подождите 1–2 минуты и повторите попытку. Вы можете продолжить редактирование вручную.",
      });
      rateLimitToastShownRef.current = true;
    }
  };

  const isRateLimitError = (error: GigaChatError) =>
    typeof error.code === "string" && error.code.includes("429");

  const handleContentChange = (id: string, content: string) => {
    setSections(sections.map(s => s.id === id ? { ...s, content } : s));
  };

  const handleHumanize = async (id: string) => {
    const section = sections.find(s => s.id === id);
    if (!section || !section.content) {
      toast.error("Сначала сгенерируйте текст для этого раздела");
      return;
    }

    if (rateLimitReachedRef.current) {
      notifyRateLimit();
      return;
    }

    setHumanizingId(id);
    toast.loading("Очеловечиваем текст...", { id: 'humanize' });

    try {
      const humanized = await humanizeText(section.content);
      setSections(sections.map(s => s.id === id ? { ...s, content: humanized } : s));
      toast.success("Текст успешно улучшен!", { id: 'humanize' });
    } catch (error) {
      console.error('Error humanizing text:', error);
      
      if (error instanceof GigaChatError) {
        if (isRateLimitError(error) || /лимит|too many/i.test(error.message)) {
          notifyRateLimit('humanize');
        } else {
          toast.error(`Ошибка: ${error.message}`, { id: 'humanize' });
        }
      } else {
        toast.error("Не удалось улучшить текст", { id: 'humanize' });
      }
    } finally {
      setHumanizingId(null);
    }
  };

  const handleGenerateTable = async (sectionId: string, tableType: TableType) => {
    const section = sections.find(s => s.id === sectionId);
    if (!section) return;

    if (rateLimitReachedRef.current) {
      notifyRateLimit();
      return;
    }

    setGeneratingTable({ sectionId, type: tableType });
    toast.loading("Генерируем таблицу...", { id: 'generate-table' });

    try {
      const table = await generateTable(theme, section.title, section.description, tableType);
      
      setSections(sections.map(s => 
        s.id === sectionId 
          ? { ...s, tables: [...(s.tables || []), table] }
          : s
      ));
      
      toast.success("Таблица успешно создана!", { id: 'generate-table' });
    } catch (error) {
      console.error('Error generating table:', error);
      if (error instanceof GigaChatError) {
        if (isRateLimitError(error) || /лимит|too many/i.test(error.message)) {
          notifyRateLimit('generate-table');
        } else {
          toast.error(`Ошибка: ${error.message}`, { id: 'generate-table' });
        }
      } else {
        toast.error("Не удалось создать таблицу", { id: 'generate-table' });
      }
    } finally {
      setGeneratingTable(null);
    }
  };

  useEffect(() => {
    let cancelled = false;
    const generateMissingTables = async () => {
      // Сортируем разделы по приоритету таблиц (сначала высокий приоритет)
      const sectionsToAnalyze = sections
        .filter(s => s.content) // Только разделы с контентом
        .map(s => ({ section: s, priority: 0 }))
        .sort((a, b) => {
          // Сначала разделы без таблиц
          const aHasTable = a.section.tables && a.section.tables.length > 0;
          const bHasTable = b.section.tables && b.section.tables.length > 0;
          if (aHasTable !== bHasTable) return aHasTable ? 1 : -1;
          return 0;
        });

      for (const { section } of sectionsToAnalyze) {
        if (cancelled) {
          break;
        }

        if (rateLimitReachedRef.current) {
          break;
        }

        const alreadyGenerated = autoGeneratedTables.current.has(section.id);
        const needsTable = !section.tables || section.tables.length === 0;

        if (!needsTable || alreadyGenerated) {
          continue;
        }

        try {
          // Анализируем раздел для определения необходимости таблицы
          const analysis = await analyzeSectionForVisuals(
            section.title,
            section.description,
            section.content
          );

          // Генерируем таблицу только если анализ показал, что она нужна
          // Приоритет: high - всегда, medium - всегда, low - только если явно упоминается
          const shouldGenerate = analysis.needsTable && (
            analysis.tablePriority === 'high' ||
            analysis.tablePriority === 'medium' ||
            (analysis.tablePriority === 'low' && section.content && /таблиц[аеиуы]?|table/i.test(section.content))
          );

          if (shouldGenerate && analysis.tableType) {
            const table = await generateTable(
              theme,
              section.title,
              section.description,
              analysis.tableType
            );
            
            if (cancelled) {
              break;
            }

            autoGeneratedTables.current.add(section.id);
            setSections(prevSections => prevSections.map(s => s.id === section.id ? {
              ...s,
              tables: [...(s.tables || []), table],
            } : s));
          } else {
            // Помечаем как обработанный, чтобы не анализировать повторно
            autoGeneratedTables.current.add(section.id);
          }
        } catch (error) {
          console.error('Auto table generation failed:', error);
          autoGeneratedTables.current.add(section.id); // Помечаем, чтобы не зациклиться
          if (error instanceof GigaChatError && (isRateLimitError(error) || /лимит|too many/i.test(error.message))) {
            notifyRateLimit();
            break;
          }
        }
      }
    };

    generateMissingTables();

    return () => {
      cancelled = true;
    };
  }, [sections, theme]);

  useEffect(() => {
    let cancelled = false;

    const autoHumanize = async () => {
      for (const section of sections) {
        if (cancelled) {
          break;
        }
        if (!section.content) {
          continue;
        }
        if (autoHumanizedSections.current.has(section.id)) {
          continue;
        }

        if (rateLimitReachedRef.current) {
          break;
        }

        const hasMarkers = /(по моему мнению|следует отметить|одним из ключевых|таким образом|во-первых|во-вторых)/i.test(
          section.content,
        );
        if (!hasMarkers) {
          continue;
        }

        try {
          const humanized = await humanizeText(section.content);
          if (cancelled) {
            return;
          }
          autoHumanizedSections.current.add(section.id);
          setSections((prev) =>
            prev.map((s) => (s.id === section.id ? { ...s, content: humanized } : s)),
          );
        } catch (error) {
          console.error('Auto humanize failed:', error);
          autoHumanizedSections.current.add(section.id);
          if (error instanceof GigaChatError && (isRateLimitError(error) || /лимит|too many/i.test(error.message))) {
            notifyRateLimit();
            break;
          }
        }
      }
    };

    autoHumanize();

    return () => {
      cancelled = true;
    };
  }, [sections]);

  useEffect(() => {
    let cancelled = false;

    const ensureCharts = async () => {
      // Проверяем, есть ли графики в документе
      let hasCharts = sections.some((section) => section.charts && section.charts.length > 0);

      // Сортируем разделы: сначала без графиков
      const sectionsToAnalyze = sections
        .filter(s => s.content) // Только разделы с контентом
        .map(s => ({ section: s, priority: 0 }))
        .sort((a, b) => {
          const aHasChart = a.section.charts && a.section.charts.length > 0;
          const bHasChart = b.section.charts && b.section.charts.length > 0;
          if (aHasChart !== bHasChart) return aHasChart ? 1 : -1;
          return 0;
        });

      for (const { section } of sectionsToAnalyze) {
        if (cancelled) {
          break;
        }

        if (rateLimitReachedRef.current) {
          break;
        }

        const needsChart = !section.charts || section.charts.length === 0;
        const alreadyGenerated = autoGeneratedCharts.current.has(section.id);

        if (!needsChart || alreadyGenerated) {
          continue;
        }

        try {
          // Анализируем раздел для определения необходимости графика
          const analysis = await analyzeSectionForVisuals(
            section.title,
            section.description,
            section.content
          );

          // Генерируем график только если анализ показал, что он нужен
          // Приоритет: high - всегда, medium - всегда, low - только если явно упоминается или если вообще нет графиков
          const mentionsChart = section.content && /график|диаграмм|динамик|рисунк/i.test(section.content);
          const shouldGenerate = analysis.needsChart && (
            analysis.chartPriority === 'high' ||
            analysis.chartPriority === 'medium' ||
            (analysis.chartPriority === 'low' && (mentionsChart || !hasCharts))
          );

          if (shouldGenerate && analysis.chartType) {
            const chart = await generateChartData(
              theme,
              section.title,
              section.description,
              analysis.chartType
            );
            
            if (cancelled) {
              break;
            }

            autoGeneratedCharts.current.add(section.id);
            hasCharts = true;
            setSections((prev) =>
              prev.map((s) =>
                s.id === section.id
                  ? {
                      ...s,
                      charts: [...(s.charts || []), chart],
                    }
                  : s,
              ),
            );
          } else {
            // Помечаем как обработанный
            autoGeneratedCharts.current.add(section.id);
          }
        } catch (error) {
          console.error('Auto chart generation failed:', error);
          autoGeneratedCharts.current.add(section.id); // Помечаем, чтобы не зациклиться
          if (error instanceof GigaChatError && (isRateLimitError(error) || /лимит|too many/i.test(error.message))) {
            notifyRateLimit();
            break;
          }
        }
      }
    };

    ensureCharts();

    return () => {
      cancelled = true;
    };
  }, [sections, theme]);

  const handleGenerateChart = async (sectionId: string, chartType: 'line' | 'bar' | 'pie') => {
    const section = sections.find(s => s.id === sectionId);
    if (!section) return;

    if (rateLimitReachedRef.current) {
      notifyRateLimit();
      return;
    }

    setGeneratingChart({ sectionId, type: chartType });
    toast.loading("Генерируем график...", { id: 'generate-chart' });

    try {
      const chart = await generateChartData(theme, section.title, section.description, chartType);
      
      setSections(sections.map(s => 
        s.id === sectionId 
          ? { ...s, charts: [...(s.charts || []), chart] }
          : s
      ));
      
      toast.success("График успешно создан!", { id: 'generate-chart' });
    } catch (error) {
      console.error('Error generating chart:', error);
      if (error instanceof GigaChatError) {
        if (isRateLimitError(error) || /лимит|too many/i.test(error.message)) {
          notifyRateLimit('generate-chart');
        } else {
          toast.error(`Ошибка: ${error.message}`, { id: 'generate-chart' });
        }
      } else {
        toast.error("Не удалось создать график", { id: 'generate-chart' });
      }
    } finally {
      setGeneratingChart(null);
    }
  };

  const handleDeleteTable = (sectionId: string, tableIndex: number) => {
    setSections(sections.map(s => 
      s.id === sectionId 
        ? { ...s, tables: (s.tables || []).filter((_, i) => i !== tableIndex) }
        : s
    ));
  };

  const handleDeleteChart = (sectionId: string, chartIndex: number) => {
    setSections(sections.map(s => 
      s.id === sectionId 
        ? { ...s, charts: (s.charts || []).filter((_, i) => i !== chartIndex) }
        : s
    ));
  };

  const handleSubmit = () => {
    toast.success("Переходим к оформлению титульного листа");
    onNext(sections);
  };

  return (
    <div className="max-w-5xl mx-auto">
      <div className="text-center mb-8 space-y-4">
        <h2 className="text-3xl md:text-4xl font-bold text-foreground">
          Редактор документа
        </h2>
        <p className="text-lg text-muted-foreground">
          Просмотрите и отредактируйте содержание перед экспортом
        </p>
      </div>

      <Tabs value={activeTab} onValueChange={setActiveTab} className="mb-8">
        <TabsList className="grid w-full grid-cols-2">
          <TabsTrigger value="edit" className="flex items-center gap-2">
            <FileText className="h-4 w-4" />
            Редактирование
          </TabsTrigger>
          <TabsTrigger value="preview" className="flex items-center gap-2">
            <Eye className="h-4 w-4" />
            Предпросмотр
          </TabsTrigger>
        </TabsList>

        <TabsContent value="edit" className="space-y-6 mt-6">
          <Alert className="bg-muted/40 border-dashed">
            <AlertTitle className="flex items-center gap-2 text-base">
              <Lightbulb className="h-4 w-4" />
              Как работать с таблицами и графиками
            </AlertTitle>
            <AlertDescription className="text-sm">
              Таблицы и графики автоматически нумеруются при экспорте. Если нужно изменить данные, удалите элемент и сгенерируйте заново или поправьте его уже в Word после скачивания документа.
            </AlertDescription>
          </Alert>

          {sections.map((section, index) => (
            <Card key={section.id} className="p-6">
              <div className="flex items-center justify-between mb-4">
                <div className="flex items-center gap-3">
                  <span className="flex h-8 w-8 items-center justify-center rounded-full bg-primary/10 text-primary text-sm font-bold">
                    {index + 1}
                  </span>
                  <h3 className="text-xl font-semibold text-card-foreground">
                    {section.title}
                  </h3>
                </div>
                <Button
                  onClick={() => handleHumanize(section.id)}
                  disabled={!section.content || humanizingId !== null}
                  size="sm"
                  variant="outline"
                >
                  {humanizingId === section.id ? (
                    <>
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      Обработка...
                    </>
                  ) : (
                    <>
                      <Sparkles className="h-4 w-4 mr-2" />
                      Очеловечить
                    </>
                  )}
                </Button>
              </div>
              <Textarea
                value={section.content || ""}
                onChange={(e) => handleContentChange(section.id, e.target.value)}
                rows={8}
                className="font-mono text-sm mb-4"
                disabled={humanizingId === section.id}
              />

              {/* Таблицы */}
              {section.tables && section.tables.length > 0 && (
                <div className="mb-4 space-y-4">
                  {section.tables.map((table, tableIndex) => (
                    <div key={tableIndex} className="border rounded-lg p-4 bg-muted/50">
                      <div className="flex items-center justify-between mb-2">
                        <h4 className="font-semibold text-sm">{table.title}</h4>
                        <Button
                          size="sm"
                          variant="ghost"
                          onClick={() => handleDeleteTable(section.id, tableIndex)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                      <div className="overflow-x-auto">
                        <table className="w-full text-sm border-collapse">
                          <thead>
                            <tr className="border-b">
                              {table.headers.map((header, i) => (
                                <th key={i} className="p-2 text-left font-semibold border-r last:border-r-0">
                                  {header}
                                </th>
                              ))}
                            </tr>
                          </thead>
                          <tbody>
                            {table.rows.map((row, rowIndex) => (
                              <tr key={rowIndex} className="border-b">
                                {row.map((cell, cellIndex) => (
                                  <td key={cellIndex} className="p-2 border-r last:border-r-0">
                                    {cell}
                                  </td>
                                ))}
                              </tr>
                            ))}
                          </tbody>
                        </table>
                      </div>
                      {table.caption && (
                        <p className="text-xs text-muted-foreground mt-2 italic">{table.caption}</p>
                      )}
                    </div>
                  ))}
                </div>
              )}

              {/* Графики */}
              {section.charts && section.charts.length > 0 && (
                <div className="mb-4 space-y-4">
                  {section.charts.map((chart, chartIndex) => (
                    <div key={chartIndex} className="border rounded-lg p-4 bg-muted/50">
                      <div className="flex items-center justify-between mb-2">
                        <h4 className="font-semibold text-sm">{chart.title}</h4>
                        <Button
                          size="sm"
                          variant="ghost"
                          onClick={() => handleDeleteChart(section.id, chartIndex)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                      <div className="bg-white p-4 rounded border">
                        <p className="text-xs text-muted-foreground mb-2">
                          График будет добавлен в DOCX при экспорте
                        </p>
                        <p className="text-xs">Тип: {chart.type === 'line' ? 'Линейный' : chart.type === 'bar' ? 'Столбчатый' : 'Круговой'}</p>
                        <p className="text-xs">Метки: {chart.labels.join(', ')}</p>
                        {chart.caption && (
                          <p className="text-xs text-muted-foreground mt-2 italic">{chart.caption}</p>
                        )}
                      </div>
                    </div>
                  ))}
                </div>
              )}

              {/* Кнопки добавления таблиц/графиков */}
              <div className="flex gap-2 flex-wrap">
                <div className="flex gap-2">
                  <Button
                    size="sm"
                    variant="outline"
                    onClick={() => handleGenerateTable(section.id, 'comparative')}
                    disabled={generatingTable !== null}
                  >
                    <Table2 className="h-4 w-4 mr-2" />
                    {generatingTable?.sectionId === section.id && generatingTable.type === 'comparative' ? (
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                    ) : null}
                    Сравнительная
                  </Button>
                  <Button
                    size="sm"
                    variant="outline"
                    onClick={() => handleGenerateTable(section.id, 'dynamic')}
                    disabled={generatingTable !== null}
                  >
                    <Table2 className="h-4 w-4 mr-2" />
                    Динамика
                  </Button>
                  <Button
                    size="sm"
                    variant="outline"
                    onClick={() => handleGenerateTable(section.id, 'classification')}
                    disabled={generatingTable !== null}
                  >
                    <Table2 className="h-4 w-4 mr-2" />
                    Классификация
                  </Button>
                </div>
                <div className="flex gap-2">
                  <Button
                    size="sm"
                    variant="outline"
                    onClick={() => handleGenerateChart(section.id, 'line')}
                    disabled={generatingChart !== null}
                  >
                    <BarChart3 className="h-4 w-4 mr-2" />
                    График
                  </Button>
                  <Button
                    size="sm"
                    variant="outline"
                    onClick={() => handleGenerateChart(section.id, 'bar')}
                    disabled={generatingChart !== null}
                  >
                    <BarChart3 className="h-4 w-4 mr-2" />
                    Столбчатый
                  </Button>
                  <Button
                    size="sm"
                    variant="outline"
                    onClick={() => handleGenerateChart(section.id, 'pie')}
                    disabled={generatingChart !== null}
                  >
                    <BarChart3 className="h-4 w-4 mr-2" />
                    Круговой
                  </Button>
                </div>
              </div>
            </Card>
          ))}
        </TabsContent>

        <TabsContent value="preview" className="mt-6">
          <Card className="p-8 md:p-12 bg-card prose prose-slate max-w-none">
            {sections.map((section, index) => (
              <div key={section.id} className="mb-8">
                <h2 className="text-2xl font-bold mb-4 text-card-foreground">
                  {index + 1}. {section.title}
                </h2>
                <div className="whitespace-pre-wrap text-muted-foreground leading-relaxed">
                  {section.content}
                </div>
              </div>
            ))}
          </Card>
        </TabsContent>
      </Tabs>

      <div className="flex gap-4">
        <Button onClick={onBack} variant="outline" size="lg" className="flex-1">
          Назад
        </Button>
        <Button onClick={handleSubmit} variant="hero" size="lg" className="flex-1">
          Далее: Титульный лист
        </Button>
      </div>
    </div>
  );
};
